<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom">            <title type="text">Ezone</title>    <updated>2021-01-28T16:59:13+08:00</updated>        <id></id>        <link rel="alternate" type="text/html" href="" />        <link rel="self" type="application/atom+xml" href="/atom.xml" />    <rights>Copyright © 2021, Ezone</rights>    <generator uri="http://eadron.com" version="unknown">Halo</generator>            <entry>                <title><![CDATA[spring boot自动配置]]></title>                <link rel="alternate" type="text/html" href="/archives/s-p-r-i-n-g--b-o-o-t-zi-dong-pei-zhi.html" />                <id>tag:,2021-01-14:s-p-r-i-n-g--b-o-o-t-zi-dong-pei-zhi</id>                <published>2021-01-14T16:37:49+08:00</published>                <updated>2021-01-14T16:37:49+08:00</updated>                <author>                    <name>eadron</name>                    <uri></uri>                </author>                <content type="html">                        <![CDATA[<h1 id="spring-boot是怎样实现自动配置的">spring boot是怎样实现自动配置的?</h1><h2 id="intro">Intro</h2><p>spring boot框架的产生,最主要的目的,是为了解决spring框架日益繁复的配置问题.它实现了自动配置,换句话说,自动配置是spring boot最核心的功能.而spring boot是怎样实现自动配置的呢?</p><h2 id="1spring-web-配置方式的演化">1.spring web 配置方式的演化</h2><p>spring web的配置方式,经历了从web.xml, 到annotation config,到java config,最后到现在springboot自动配置的方式.</p><h3 id="11使用webxml方式">1.1使用web.xml方式</h3><p>早期的spring web,使用的是web.xml的方式进行配置的.spring是基于servlet规范的,所以它可以使用规范中xml的方式进行配置.只不过,spring将跟spring容器相关的配置,抽取到单独的xml文件中.</p><ul><li>示例代码<ul><li>源码地址<br /><a href="https://github.com/eadronlin/javaStudy/tree/master/springXmlConfig">https://github.com/eadronlin/javaStudy/tree/master/springXmlConfig</a></li><li>示例</li></ul></li></ul><h3 id="12使用annotation进行改善的方式">1.2使用annotation进行改善的方式</h3><p>Servlet 规范从  <a href="http://download.oracle.com/otn-pub/jcp/servlet-2.5-mr5-oth-JSpec/servlet-2.5-mr5-spec.pdf">2.5版本</a>起,开始支持annotation. spring利用了这个新功能,对spring的配置进行了改善:bean不再需要手动配置到xml中,而是通过注解,就能注册到spring容器中.</p><ul><li>示例代码<ul><li>源码地址<br /><a href="https://github.com/eadronlin/javaStudy/tree/master/springAnnotationConfig">https://github.com/eadronlin/javaStudy/tree/master/springAnnotationConfig</a></li></ul></li></ul><h3 id="13使用java-config方式">1.3使用Java config方式</h3><p><a href="https://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf">servlet 3.0</a>起,servlet 增加了ServletContainerInitializer接口支持使用java代码的方式代替xml配置,从此java web可以完全摆脱xml配置的束缚.而相应的spring增加了WebApplicationInitializer接口(spring基于servlet,因此其具体的做法应该是实现ServletContainerInitializer接口,然后调用WebApplicationInitializer).</p><ul><li>示例代码<ul><li>源码地址<br /><a href="https://github.com/eadronlin/javaStudy/tree/master/springJavaConfig">https://github.com/eadronlin/javaStudy/tree/master/springJavaConfig</a></li></ul></li></ul><h3 id="14spring-boot自动配置方式">1.4spring boot自动配置方式</h3><p>2014年,spring boot发布.它内置了默认配置,使得开发者繁复的配置工作中解脱出来.</p><ul><li>示例代码<ul><li>源码地址<br /><a href="https://github.com/eadronlin/javaStudy/tree/master/springBootAutoConfig">springBootAutoConfig</a></li></ul></li></ul><h2 id="2如果是自己要实现spring-web自动配置要做什么事情">2.如果是自己要实现spring web自动配置,要做什么事情?</h2><p>1.创建servlet context,并注册Dispatcher Servlet<br />2.创建spring context,往spring container 注册bean</p><p>那么在哪做这些事情?ServletContainerInitializer接口、WebApplicationInitializer接口的 onStartup方法,会在servlet容器启动时自动加载并且运行.由此猜想,spring boot要完成自动配置的一些前置工作,切入点应该就在这里,当然,servlet 容器的创建,在onStartup之前.</p><p>WebApplicationInitializer接口<br />annotation,注解在spring boot中主要起什么作用?自动注册bean?<br />spring boot怎么扫描需要自动注册的信息的?<br />定义默认配置,默认配置定义在哪?spring boot怎么使用默认配置的?</p><h3 id="21spring-boot怎么创建servlet-容器的">2.1spring boot怎么创建servlet 容器的?</h3><p>spring boot是可执行程序,虚拟机直接加载其执行起点:main()函数.从main()追踪:<br />SpringApplication.run() -&gt;<br />SpringApplication.createApplicationContext() -&gt;<br />SpringApplication.refresh() -&gt;<br />ServletWebServerApplicationContext.createWebServer()<br />创建servlet容器后,下一步将执行ServletContainerInitializer.onStartup,调用代码:</p><pre><code>StandardContext.startInternal():// Call ServletContainerInitializersfor (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :    initializers.entrySet()) {    try {//        entry.getKey().onStartup(entry.getValue(),                getServletContext());    } catch (ServletException e) {        log.error(sm.getString(&quot;standardContext.sciFail&quot;), e);        ok = false;        break;    }}</code></pre><h3 id="22spring-boot怎么注册-dispatcher-servlet的">2.2spring boot怎么注册 Dispatcher Servlet的?</h3><p>spring boot 是使用内嵌服务器,servlet 容器创建后的执行点</p><ul><li>tomcat<pre><code>ServletWebServerApplicationContext.getWebServerFactory()</code></pre></li></ul><p>//tomcatServletWebServerFactory</p><p>//为什么注册Dispatcher Servlet比 onStarterup先执行?不过也是可以的,因为servlet context 已经创建了.<br />//非内嵌服务器的实现,Dispatcher Servlet是在WebApplicationInitializer.onStartup中注册的<br />@ConditionalOnClass(DispatcherServlet.class)<br />org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration.dispatcherServlet</p><p>TomcatStarter.onStartup(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext)</p><pre><code>- 题外:非内嵌服务器      - SpringServletContainerInitializer            SpringServletContainerInitializer实现了ServletContainerInitializer接口HostConfig.manageApp(Context context)-&gt;StandardContext.startInternal() -&gt; SpringServletContainerInitializer.startup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)      - AbstractDispatcherServletInitializer            ~~AbstractDispatcherServletInitializer是实现WebApplicationInitializer接口的抽象类,其onStartup方法实现如下:</code></pre><p>@Override<br />public void onStartup(ServletContext servletContext) throws ServletException {<br />super.onStartup(servletContext);<br />registerDispatcherServlet(servletContext);<br />}</p><pre><code>这是注册 Dispatcher Servlet 的一个地方调试1中的4种注册方式,只有 java config的方式,会调用到这里.那么其他三种方式,是在哪里注册的?继续调试 java config,查找调用的根源,看能否从源头找出什么线索.找到调用 AbstractDispatcherServletInitializer.onStartup的地方,是在SpringServletContainerInitializer类的onStartup中.SpringServletContainerInitializer实现了ServletContainerInitializer接口.所以故事应该从SpringServletContainerInitializer说起~~### 2.3Spring boot 怎么创建 spring context的?### 2.4spring boot 怎么注册各种bean的?### spring boot 的 ApplicationContext 有什么作用,它与WebApplicationContext什么关系?      org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext### 主要原理   - @EnableAutoConfiguration         @EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。@Import(AutoConfigurationImportSele-ctor.class)又可以分为两部分：@Import和对应的ImportSelector。      - @Import   - @Conditional   - @Configuration   - @Bean   - spring-boot-autoconfigure-2.3.1.RELEASE.jar/META-INF/spring.factories   - spring-boot-autoconfigure-2.3.1.RELEASE.jar/META-INF/spring-autoconfigure-metadata.properties   - ServletWebServerFactoryConfiguration         ![](https://thepracticaldeveloper.com/images/posts/uploads/2020/04/auto-configuration.png)## 3.spring boot启动过程### ## 开启spring boot 调试模式## web.xml  WebApplicationInitializer### 1 web.xml是直接由servlet container 实例化的### 接口WebApplicationInitializer，用于替代web.xml配置文件。实现该接口的类会在Servlet容器启动时自动加载并运行。   - xml         ```&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;         version=&quot;3.0&quot;&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;&lt;/web-app&gt;```   - 代码直接实现         ```public class MyWebAppInitializer implements WebApplicationInitializer {        /**        * Servlet容器启动时会自动运行该方法        */        @Override        public void onStartup(ServletContext servletContext) throws ServletException {        servletContext.setInitParameter(&quot;contextConfigLocation&quot;, &quot;classpath:applicationContext.xml&quot;);        ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet());        registration.setLoadOnStartup(1);        registration.addMapping(&quot;/&quot;);        registration.setInitParameter(&quot;contextConfigLocation&quot;, &quot;classpath:dispatcher-servlet.xml&quot;);        servletContext.addListener(new ContextLoaderListener());        }        }```## 各种spring xml 注解### @EnableAutoConfiguration注解   - 源码         ```@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration {   String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;   /**    * Exclude specific auto-configuration classes such that they will never be applied.    * @return the classes to exclude    */   Class&lt;?&gt;[] exclude() default {};   /**    * Exclude specific auto-configuration class names such that they will never be    * applied.    * @return the class names to exclude    * @since 1.3.0    */   String[] excludeName() default {};}```   - @Import         ```@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import {   /**    * {@link Configuration @Configuration}, {@link ImportSelector},    * {@link ImportBeanDefinitionRegistrar}, or regular component classes to import.    */   Class&lt;?&gt;[] value();}```      - @Import 提供了和在xml配置文件中的&lt;import/&gt;标签相同的能力。允许我们导入注解了@Configuration的类，或者是实现了ImportSelector或者ImportBeanDefinitionRegistrar接口的实现类。   - @EnableAutoConfiguration上的@Import引入了一个AutoConfigutationImportSelector.class的类。   - AutoConfigurationImportSelector      - AutoConfigurationImportSelector源码## 定义bean的不同方式   https://www.ibm.com/developerworks/cn/webservices/ws-springjava/index.html### xml的方式   - xml文件         ```&lt;beans&gt;    &lt;bean id=&quot;course&quot; class=&quot;demo.Course&quot;&gt;        &lt;property name=&quot;module&quot; ref=&quot;module&quot;/&gt;    &lt;/bean&gt;       &lt;bean id=&quot;module&quot; class=&quot;demo.Module&quot;&gt;        &lt;property name=&quot;assignment&quot; ref=&quot;assignment&quot;/&gt;    &lt;/bean&gt;       &lt;bean id=&quot;assignment&quot; class=&quot;demo.Assignment&quot; /&gt;&lt;/beans&gt;```## 参考资料### http://zetcode.com/articles/springwebfirst/</code></pre>]]>                </content>            </entry></feed>